{% extends "utils/base.html" %}
{% block title %}Create Your Own Route{% endblock %}
{% block content %}
<div class="route-page">
    <div class="route-header">
        <h1 class="route-title">Generate New Route</h1>
        <div class="route-description">
            <p>Customize your route by selecting props, difficulty, and length. Get a personalized sequence of tricks to practice.</p>
        </div>
    </div>

    <form method="POST" action="{{ url_for('generate_route') }}" class="route-form">
        <div class="form-section">
            <label for="route_name" class="form-label">Route Name</label>
            <input type="text" id="route_name" name="route_name" placeholder="My awesome route" class="form-input" required>
        </div>

        <div class="form-section">
            <label class="form-label">Select Prop</label>
            <div class="prop-group">
                {% for prop in prop_options %}
                    <label class="prop-option {% if loop.first %}selected{% endif %}" data-prop-type="{{ prop }}">
                        <input type="radio" name="prop" class="prop-option-input" value="{{ prop }}" {% if loop.first %}checked{% endif %}> 
                        <span class="prop-option-name">{{ prop }}</span>
                        <div class="prop-icon"></div>
                    </label>
                {% endfor %}
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Props Count</label>
            <div class="slider-container">
                <div id="props-slider" class="custom-slider"></div>
                <div class="slider-values">
                    <span id="props-range">Min: 3, Max: 9</span>
                </div>
                <input type="hidden" id="min-props-input" name="min_props" value="3">
                <input type="hidden" id="max-props-input" name="max_props" value="9">
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Difficulty Range</label>
            <div class="slider-container">
                <div id="difficulty-slider" class="custom-slider"></div>
                <div class="slider-values">
                    <span id="difficulty-range">Min: 20, Max: 30</span>
                </div>
                <input type="hidden" id="min-difficulty-input" name="min_difficulty" value="20">
                <input type="hidden" id="max-difficulty-input" name="max_difficulty" value="30">
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Exclude Tags</label>
            <div class="tricks-container">
                <div class="tricks-column">
                    <div id="exclude_tags" class="tags-grid">
                        {% for tag in tag_options %}
                            <div class="checkbox-container">
                                <input type="checkbox" id="tag-{{ tag }}" name="exclude_tags" value="{{ tag }}">
                                <label for="tag-{{ tag }}">{{ tag }}</label>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Tricks</label>
            <div class="tricks-container">
                <div class="tricks-column">
                    <div id="all_tricks" class="tricks-grid">
                        <!-- Tricks will be populated by updateTricks function -->
                    </div>
                </div>
            </div>
        </div>
    </form>

    <div class="tricks-database">
        <p>Juggler and Open-Source contributor? You can expand the database <a target="_blank" href="https://github.com/ofekraf/jugglefit_website/tree/main/database/tricks">here</a></p>
    </div>
</div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>

<!-- Pass Flask data to JavaScript -->
<script>
    // Convert Flask template data to JavaScript object
    const propToTricks = {{ prop_to_tricks|tojson|safe }};
</script>

<script>
    // Initialize the props slider (range 3 to 7)
    const propsSlider = document.getElementById('props-slider');
    const propsRange = document.getElementById('props-range');
    const propsMinInput = document.getElementById('min-props-input');
    const propsMaxInput = document.getElementById('max-props-input');

    // Initialize the difficulty slider (range 0 to 100)
    const difficultySlider = document.getElementById('difficulty-slider');
    const difficultyRange = document.getElementById('difficulty-range');  
    const difficultyMinInput = document.getElementById('min-difficulty-input');
    const difficultyMaxInput = document.getElementById('max-difficulty-input');

    // Prop selection handling
    const propOptions = document.querySelectorAll('.prop-option');
    const propInputs = document.querySelectorAll('.prop-option-input');

    // Function to update selected state
    function updateSelectedState() {
        propOptions.forEach(option => {
            const input = option.querySelector('.prop-option-input');
            if (input.checked) {
                option.classList.add('selected');
            } else {
                option.classList.remove('selected');
            }
        });
    }

    // Set initial state
    updateSelectedState();

    // Add click event listeners to all prop options
    propOptions.forEach(option => {
        option.addEventListener('click', function() {
            // Uncheck all inputs
            propInputs.forEach(input => input.checked = false);
            // Check the clicked input
            const input = this.querySelector('.prop-option-input');
            input.checked = true;
            updateSelectedState();
        });
    });

    // Add change event listeners to all radio inputs
    propInputs.forEach(input => {
        input.addEventListener('change', updateSelectedState);
    });

    // Add event listeners for filtering
    const searchElement = document.getElementById('search');
    if (searchElement) {
        searchElement.addEventListener('input', filterTricks);
    }
    
    // Add event listeners for tag checkboxes
    document.querySelectorAll('input[name="exclude_tags"]').forEach(checkbox => {
        checkbox.addEventListener('change', filterTricks);
    });

    // Add event listener for prop selection
    document.querySelectorAll('input[name="prop"]').forEach(radio => {
        radio.addEventListener('change', filterTricks);
    });

    // Initial filter and update tricks
    filterTricks();
    updateTricks();

    // Function to update tricks display
    function updateTricks() {
        const tricksGrid = document.getElementById('all_tricks');
        tricksGrid.innerHTML = '';

        // Get the selected prop type
        const selectedProp = document.querySelector('input[name="prop"]:checked')?.value;
        if (!selectedProp || !propToTricks[selectedProp]) return;

        // Get tricks for the selected prop
        const tricks = propToTricks[selectedProp];

        // Group tricks by props count
        const groupedTricks = {};
        tricks.forEach(trick => {
            if (!groupedTricks[trick.props_count]) {
                groupedTricks[trick.props_count] = [];
            }
            groupedTricks[trick.props_count].push(trick);
        });

        // Display tricks grouped by props count
        Object.keys(groupedTricks).sort((a, b) => parseInt(a) - parseInt(b)).forEach(count => {
            const group = document.createElement('div');
            group.className = 'props-group';
            
            const header = document.createElement('h3');
            header.className = 'props-count-header';
            header.textContent = `${count} Props`;
            group.appendChild(header);
            
            const tricksList = document.createElement('div');
            tricksList.className = 'tricks-list';
            
            // Sort tricks by name within each group
            groupedTricks[count].sort((a, b) => a.name.localeCompare(b.name)).forEach(trick => {
                const trickItem = document.createElement('div');
                trickItem.className = 'trick-item';
                trickItem.textContent = trick.name;
                tricksList.appendChild(trickItem);
            });
            
            group.appendChild(tricksList);
            tricksGrid.appendChild(group);
        });
    }

    function filterTricks() {
        const searchTerm = document.getElementById('search')?.value?.toLowerCase() || '';
        const selectedProp = document.querySelector('input[name="prop"]:checked')?.value;
        const minProps = parseInt(document.getElementById('min-props-input').value);
        const maxProps = parseInt(document.getElementById('max-props-input').value);
        const minDifficulty = parseInt(document.getElementById('min-difficulty-input').value);
        const maxDifficulty = parseInt(document.getElementById('max-difficulty-input').value);
        const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);

        // Get tricks for the selected prop
        const tricks = propToTricks[selectedProp] || [];

        // Filter tricks based on all criteria
        const filteredTricks = tricks.filter(trick => {
            // Check if trick name matches search term
            const nameMatch = trick.name.toLowerCase().includes(searchTerm);
            
            // Check if props count is within range
            const propsCountMatch = trick.props_count >= minProps && trick.props_count <= maxProps;
            
            // Check if difficulty is within range
            const difficultyMatch = trick.difficulty >= minDifficulty && trick.difficulty <= maxDifficulty;
            
            // Check if trick doesn't have any excluded tags
            const tagsMatch = !excludedTags.some(tag => trick.tags.includes(tag));
            
            return nameMatch && propsCountMatch && difficultyMatch && tagsMatch;
        });

        // Group filtered tricks by props count
        const groupedTricks = {};
        filteredTricks.forEach(trick => {
            if (!groupedTricks[trick.props_count]) {
                groupedTricks[trick.props_count] = [];
            }
            groupedTricks[trick.props_count].push(trick);
        });

        // Update the tricks display
        const tricksGrid = document.getElementById('all_tricks');
        tricksGrid.innerHTML = '';

        // Display tricks grouped by props count
        Object.keys(groupedTricks).sort((a, b) => parseInt(a) - parseInt(b)).forEach(count => {
            const group = document.createElement('div');
            group.className = 'props-group';
            
            const header = document.createElement('h3');
            header.className = 'props-count-header';
            header.textContent = `${count} Props`;
            group.appendChild(header);
            
            const tricksList = document.createElement('div');
            tricksList.className = 'tricks-list';
            
            // Sort tricks by name within each group
            groupedTricks[count].sort((a, b) => a.name.localeCompare(b.name)).forEach(trick => {
                const trickItem = document.createElement('div');
                trickItem.className = 'trick-item';
                trickItem.textContent = trick.name;
                tricksList.appendChild(trickItem);
            });
            
            group.appendChild(tricksList);
            tricksGrid.appendChild(group);
        });
    }
</script>
{% endblock %}
